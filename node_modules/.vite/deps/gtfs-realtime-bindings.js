import {
  __commonJS
} from "./chunk-6TJCVOLN.js";

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer = util.inquire("buffer").Buffer;
        return Buffer.prototype.utf8Write ? Buffer : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer = util.Buffer;
      if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/gtfs-realtime-bindings/gtfs-realtime.js
var require_gtfs_realtime = __commonJS({
  "node_modules/gtfs-realtime-bindings/gtfs-realtime.js"(exports2, module2) {
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.transit_realtime = function() {
      var transit_realtime = {};
      transit_realtime.FeedMessage = function() {
        function FeedMessage(properties) {
          this.entity = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        FeedMessage.prototype.header = null;
        FeedMessage.prototype.entity = $util.emptyArray;
        FeedMessage.create = function create(properties) {
          return new FeedMessage(properties);
        };
        FeedMessage.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          $root.transit_realtime.FeedHeader.encode(message.header, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
          if (message.entity != null && message.entity.length)
            for (var i = 0; i < message.entity.length; ++i)
              $root.transit_realtime.FeedEntity.encode(message.entity[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          return writer;
        };
        FeedMessage.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        FeedMessage.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.FeedMessage();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.header = $root.transit_realtime.FeedHeader.decode(reader, reader.uint32());
                break;
              }
              case 2: {
                if (!(message.entity && message.entity.length))
                  message.entity = [];
                message.entity.push($root.transit_realtime.FeedEntity.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          if (!message.hasOwnProperty("header"))
            throw $util.ProtocolError("missing required 'header'", { instance: message });
          return message;
        };
        FeedMessage.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        FeedMessage.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          {
            var error = $root.transit_realtime.FeedHeader.verify(message.header);
            if (error)
              return "header." + error;
          }
          if (message.entity != null && message.hasOwnProperty("entity")) {
            if (!Array.isArray(message.entity))
              return "entity: array expected";
            for (var i = 0; i < message.entity.length; ++i) {
              var error = $root.transit_realtime.FeedEntity.verify(message.entity[i]);
              if (error)
                return "entity." + error;
            }
          }
          return null;
        };
        FeedMessage.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.FeedMessage)
            return object;
          var message = new $root.transit_realtime.FeedMessage();
          if (object.header != null) {
            if (typeof object.header !== "object")
              throw TypeError(".transit_realtime.FeedMessage.header: object expected");
            message.header = $root.transit_realtime.FeedHeader.fromObject(object.header);
          }
          if (object.entity) {
            if (!Array.isArray(object.entity))
              throw TypeError(".transit_realtime.FeedMessage.entity: array expected");
            message.entity = [];
            for (var i = 0; i < object.entity.length; ++i) {
              if (typeof object.entity[i] !== "object")
                throw TypeError(".transit_realtime.FeedMessage.entity: object expected");
              message.entity[i] = $root.transit_realtime.FeedEntity.fromObject(object.entity[i]);
            }
          }
          return message;
        };
        FeedMessage.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.entity = [];
          if (options.defaults)
            object.header = null;
          if (message.header != null && message.hasOwnProperty("header"))
            object.header = $root.transit_realtime.FeedHeader.toObject(message.header, options);
          if (message.entity && message.entity.length) {
            object.entity = [];
            for (var j = 0; j < message.entity.length; ++j)
              object.entity[j] = $root.transit_realtime.FeedEntity.toObject(message.entity[j], options);
          }
          return object;
        };
        FeedMessage.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        FeedMessage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.FeedMessage";
        };
        return FeedMessage;
      }();
      transit_realtime.FeedHeader = function() {
        function FeedHeader(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        FeedHeader.prototype.gtfsRealtimeVersion = "";
        FeedHeader.prototype.incrementality = 0;
        FeedHeader.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        FeedHeader.create = function create(properties) {
          return new FeedHeader(properties);
        };
        FeedHeader.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).string(message.gtfsRealtimeVersion);
          if (message.incrementality != null && Object.hasOwnProperty.call(message, "incrementality"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.incrementality);
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint64(message.timestamp);
          return writer;
        };
        FeedHeader.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        FeedHeader.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.FeedHeader();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.gtfsRealtimeVersion = reader.string();
                break;
              }
              case 2: {
                message.incrementality = reader.int32();
                break;
              }
              case 3: {
                message.timestamp = reader.uint64();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          if (!message.hasOwnProperty("gtfsRealtimeVersion"))
            throw $util.ProtocolError("missing required 'gtfsRealtimeVersion'", { instance: message });
          return message;
        };
        FeedHeader.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        FeedHeader.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (!$util.isString(message.gtfsRealtimeVersion))
            return "gtfsRealtimeVersion: string expected";
          if (message.incrementality != null && message.hasOwnProperty("incrementality"))
            switch (message.incrementality) {
              default:
                return "incrementality: enum value expected";
              case 0:
              case 1:
                break;
            }
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
              return "timestamp: integer|Long expected";
          }
          return null;
        };
        FeedHeader.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.FeedHeader)
            return object;
          var message = new $root.transit_realtime.FeedHeader();
          if (object.gtfsRealtimeVersion != null)
            message.gtfsRealtimeVersion = String(object.gtfsRealtimeVersion);
          switch (object.incrementality) {
            default:
              if (typeof object.incrementality === "number") {
                message.incrementality = object.incrementality;
                break;
              }
              break;
            case "FULL_DATASET":
            case 0:
              message.incrementality = 0;
              break;
            case "DIFFERENTIAL":
            case 1:
              message.incrementality = 1;
              break;
          }
          if (object.timestamp != null) {
            if ($util.Long)
              (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
              message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
              message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
              message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
          }
          return message;
        };
        FeedHeader.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.gtfsRealtimeVersion = "";
            object.incrementality = options.enums === String ? "FULL_DATASET" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.timestamp = options.longs === String ? "0" : 0;
          }
          if (message.gtfsRealtimeVersion != null && message.hasOwnProperty("gtfsRealtimeVersion"))
            object.gtfsRealtimeVersion = message.gtfsRealtimeVersion;
          if (message.incrementality != null && message.hasOwnProperty("incrementality"))
            object.incrementality = options.enums === String ? $root.transit_realtime.FeedHeader.Incrementality[message.incrementality] === void 0 ? message.incrementality : $root.transit_realtime.FeedHeader.Incrementality[message.incrementality] : message.incrementality;
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
              object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
              object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
          return object;
        };
        FeedHeader.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        FeedHeader.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.FeedHeader";
        };
        FeedHeader.Incrementality = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "FULL_DATASET"] = 0;
          values[valuesById[1] = "DIFFERENTIAL"] = 1;
          return values;
        }();
        return FeedHeader;
      }();
      transit_realtime.FeedEntity = function() {
        function FeedEntity(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        FeedEntity.prototype.id = "";
        FeedEntity.prototype.isDeleted = false;
        FeedEntity.prototype.tripUpdate = null;
        FeedEntity.prototype.vehicle = null;
        FeedEntity.prototype.alert = null;
        FeedEntity.create = function create(properties) {
          return new FeedEntity(properties);
        };
        FeedEntity.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).string(message.id);
          if (message.isDeleted != null && Object.hasOwnProperty.call(message, "isDeleted"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).bool(message.isDeleted);
          if (message.tripUpdate != null && Object.hasOwnProperty.call(message, "tripUpdate"))
            $root.transit_realtime.TripUpdate.encode(message.tripUpdate, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.vehicle != null && Object.hasOwnProperty.call(message, "vehicle"))
            $root.transit_realtime.VehiclePosition.encode(message.vehicle, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.alert != null && Object.hasOwnProperty.call(message, "alert"))
            $root.transit_realtime.Alert.encode(message.alert, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          return writer;
        };
        FeedEntity.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        FeedEntity.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.FeedEntity();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.id = reader.string();
                break;
              }
              case 2: {
                message.isDeleted = reader.bool();
                break;
              }
              case 3: {
                message.tripUpdate = $root.transit_realtime.TripUpdate.decode(reader, reader.uint32());
                break;
              }
              case 4: {
                message.vehicle = $root.transit_realtime.VehiclePosition.decode(reader, reader.uint32());
                break;
              }
              case 5: {
                message.alert = $root.transit_realtime.Alert.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          if (!message.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: message });
          return message;
        };
        FeedEntity.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        FeedEntity.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (!$util.isString(message.id))
            return "id: string expected";
          if (message.isDeleted != null && message.hasOwnProperty("isDeleted")) {
            if (typeof message.isDeleted !== "boolean")
              return "isDeleted: boolean expected";
          }
          if (message.tripUpdate != null && message.hasOwnProperty("tripUpdate")) {
            var error = $root.transit_realtime.TripUpdate.verify(message.tripUpdate);
            if (error)
              return "tripUpdate." + error;
          }
          if (message.vehicle != null && message.hasOwnProperty("vehicle")) {
            var error = $root.transit_realtime.VehiclePosition.verify(message.vehicle);
            if (error)
              return "vehicle." + error;
          }
          if (message.alert != null && message.hasOwnProperty("alert")) {
            var error = $root.transit_realtime.Alert.verify(message.alert);
            if (error)
              return "alert." + error;
          }
          return null;
        };
        FeedEntity.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.FeedEntity)
            return object;
          var message = new $root.transit_realtime.FeedEntity();
          if (object.id != null)
            message.id = String(object.id);
          if (object.isDeleted != null)
            message.isDeleted = Boolean(object.isDeleted);
          if (object.tripUpdate != null) {
            if (typeof object.tripUpdate !== "object")
              throw TypeError(".transit_realtime.FeedEntity.tripUpdate: object expected");
            message.tripUpdate = $root.transit_realtime.TripUpdate.fromObject(object.tripUpdate);
          }
          if (object.vehicle != null) {
            if (typeof object.vehicle !== "object")
              throw TypeError(".transit_realtime.FeedEntity.vehicle: object expected");
            message.vehicle = $root.transit_realtime.VehiclePosition.fromObject(object.vehicle);
          }
          if (object.alert != null) {
            if (typeof object.alert !== "object")
              throw TypeError(".transit_realtime.FeedEntity.alert: object expected");
            message.alert = $root.transit_realtime.Alert.fromObject(object.alert);
          }
          return message;
        };
        FeedEntity.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.id = "";
            object.isDeleted = false;
            object.tripUpdate = null;
            object.vehicle = null;
            object.alert = null;
          }
          if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
          if (message.isDeleted != null && message.hasOwnProperty("isDeleted"))
            object.isDeleted = message.isDeleted;
          if (message.tripUpdate != null && message.hasOwnProperty("tripUpdate"))
            object.tripUpdate = $root.transit_realtime.TripUpdate.toObject(message.tripUpdate, options);
          if (message.vehicle != null && message.hasOwnProperty("vehicle"))
            object.vehicle = $root.transit_realtime.VehiclePosition.toObject(message.vehicle, options);
          if (message.alert != null && message.hasOwnProperty("alert"))
            object.alert = $root.transit_realtime.Alert.toObject(message.alert, options);
          return object;
        };
        FeedEntity.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        FeedEntity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.FeedEntity";
        };
        return FeedEntity;
      }();
      transit_realtime.TripUpdate = function() {
        function TripUpdate(properties) {
          this.stopTimeUpdate = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TripUpdate.prototype.trip = null;
        TripUpdate.prototype.vehicle = null;
        TripUpdate.prototype.stopTimeUpdate = $util.emptyArray;
        TripUpdate.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TripUpdate.prototype.delay = 0;
        TripUpdate.prototype.tripProperties = null;
        TripUpdate.create = function create(properties) {
          return new TripUpdate(properties);
        };
        TripUpdate.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          $root.transit_realtime.TripDescriptor.encode(message.trip, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
          if (message.stopTimeUpdate != null && message.stopTimeUpdate.length)
            for (var i = 0; i < message.stopTimeUpdate.length; ++i)
              $root.transit_realtime.TripUpdate.StopTimeUpdate.encode(message.stopTimeUpdate[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          if (message.vehicle != null && Object.hasOwnProperty.call(message, "vehicle"))
            $root.transit_realtime.VehicleDescriptor.encode(message.vehicle, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).uint64(message.timestamp);
          if (message.delay != null && Object.hasOwnProperty.call(message, "delay"))
            writer.uint32(
              /* id 5, wireType 0 =*/
              40
            ).int32(message.delay);
          if (message.tripProperties != null && Object.hasOwnProperty.call(message, "tripProperties"))
            $root.transit_realtime.TripUpdate.TripProperties.encode(message.tripProperties, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          return writer;
        };
        TripUpdate.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TripUpdate.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.TripUpdate();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.trip = $root.transit_realtime.TripDescriptor.decode(reader, reader.uint32());
                break;
              }
              case 3: {
                message.vehicle = $root.transit_realtime.VehicleDescriptor.decode(reader, reader.uint32());
                break;
              }
              case 2: {
                if (!(message.stopTimeUpdate && message.stopTimeUpdate.length))
                  message.stopTimeUpdate = [];
                message.stopTimeUpdate.push($root.transit_realtime.TripUpdate.StopTimeUpdate.decode(reader, reader.uint32()));
                break;
              }
              case 4: {
                message.timestamp = reader.uint64();
                break;
              }
              case 5: {
                message.delay = reader.int32();
                break;
              }
              case 6: {
                message.tripProperties = $root.transit_realtime.TripUpdate.TripProperties.decode(reader, reader.uint32());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          if (!message.hasOwnProperty("trip"))
            throw $util.ProtocolError("missing required 'trip'", { instance: message });
          return message;
        };
        TripUpdate.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TripUpdate.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          {
            var error = $root.transit_realtime.TripDescriptor.verify(message.trip);
            if (error)
              return "trip." + error;
          }
          if (message.vehicle != null && message.hasOwnProperty("vehicle")) {
            var error = $root.transit_realtime.VehicleDescriptor.verify(message.vehicle);
            if (error)
              return "vehicle." + error;
          }
          if (message.stopTimeUpdate != null && message.hasOwnProperty("stopTimeUpdate")) {
            if (!Array.isArray(message.stopTimeUpdate))
              return "stopTimeUpdate: array expected";
            for (var i = 0; i < message.stopTimeUpdate.length; ++i) {
              var error = $root.transit_realtime.TripUpdate.StopTimeUpdate.verify(message.stopTimeUpdate[i]);
              if (error)
                return "stopTimeUpdate." + error;
            }
          }
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
              return "timestamp: integer|Long expected";
          }
          if (message.delay != null && message.hasOwnProperty("delay")) {
            if (!$util.isInteger(message.delay))
              return "delay: integer expected";
          }
          if (message.tripProperties != null && message.hasOwnProperty("tripProperties")) {
            var error = $root.transit_realtime.TripUpdate.TripProperties.verify(message.tripProperties);
            if (error)
              return "tripProperties." + error;
          }
          return null;
        };
        TripUpdate.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.TripUpdate)
            return object;
          var message = new $root.transit_realtime.TripUpdate();
          if (object.trip != null) {
            if (typeof object.trip !== "object")
              throw TypeError(".transit_realtime.TripUpdate.trip: object expected");
            message.trip = $root.transit_realtime.TripDescriptor.fromObject(object.trip);
          }
          if (object.vehicle != null) {
            if (typeof object.vehicle !== "object")
              throw TypeError(".transit_realtime.TripUpdate.vehicle: object expected");
            message.vehicle = $root.transit_realtime.VehicleDescriptor.fromObject(object.vehicle);
          }
          if (object.stopTimeUpdate) {
            if (!Array.isArray(object.stopTimeUpdate))
              throw TypeError(".transit_realtime.TripUpdate.stopTimeUpdate: array expected");
            message.stopTimeUpdate = [];
            for (var i = 0; i < object.stopTimeUpdate.length; ++i) {
              if (typeof object.stopTimeUpdate[i] !== "object")
                throw TypeError(".transit_realtime.TripUpdate.stopTimeUpdate: object expected");
              message.stopTimeUpdate[i] = $root.transit_realtime.TripUpdate.StopTimeUpdate.fromObject(object.stopTimeUpdate[i]);
            }
          }
          if (object.timestamp != null) {
            if ($util.Long)
              (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
              message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
              message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
              message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
          }
          if (object.delay != null)
            message.delay = object.delay | 0;
          if (object.tripProperties != null) {
            if (typeof object.tripProperties !== "object")
              throw TypeError(".transit_realtime.TripUpdate.tripProperties: object expected");
            message.tripProperties = $root.transit_realtime.TripUpdate.TripProperties.fromObject(object.tripProperties);
          }
          return message;
        };
        TripUpdate.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.stopTimeUpdate = [];
          if (options.defaults) {
            object.trip = null;
            object.vehicle = null;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.timestamp = options.longs === String ? "0" : 0;
            object.delay = 0;
            object.tripProperties = null;
          }
          if (message.trip != null && message.hasOwnProperty("trip"))
            object.trip = $root.transit_realtime.TripDescriptor.toObject(message.trip, options);
          if (message.stopTimeUpdate && message.stopTimeUpdate.length) {
            object.stopTimeUpdate = [];
            for (var j = 0; j < message.stopTimeUpdate.length; ++j)
              object.stopTimeUpdate[j] = $root.transit_realtime.TripUpdate.StopTimeUpdate.toObject(message.stopTimeUpdate[j], options);
          }
          if (message.vehicle != null && message.hasOwnProperty("vehicle"))
            object.vehicle = $root.transit_realtime.VehicleDescriptor.toObject(message.vehicle, options);
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
              object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
              object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
          if (message.delay != null && message.hasOwnProperty("delay"))
            object.delay = message.delay;
          if (message.tripProperties != null && message.hasOwnProperty("tripProperties"))
            object.tripProperties = $root.transit_realtime.TripUpdate.TripProperties.toObject(message.tripProperties, options);
          return object;
        };
        TripUpdate.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TripUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.TripUpdate";
        };
        TripUpdate.StopTimeEvent = function() {
          function StopTimeEvent(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          StopTimeEvent.prototype.delay = 0;
          StopTimeEvent.prototype.time = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          StopTimeEvent.prototype.uncertainty = 0;
          StopTimeEvent.create = function create(properties) {
            return new StopTimeEvent(properties);
          };
          StopTimeEvent.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.delay != null && Object.hasOwnProperty.call(message, "delay"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int32(message.delay);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int64(message.time);
            if (message.uncertainty != null && Object.hasOwnProperty.call(message, "uncertainty"))
              writer.uint32(
                /* id 3, wireType 0 =*/
                24
              ).int32(message.uncertainty);
            return writer;
          };
          StopTimeEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          StopTimeEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.TripUpdate.StopTimeEvent();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.delay = reader.int32();
                  break;
                }
                case 2: {
                  message.time = reader.int64();
                  break;
                }
                case 3: {
                  message.uncertainty = reader.int32();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          StopTimeEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          StopTimeEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.delay != null && message.hasOwnProperty("delay")) {
              if (!$util.isInteger(message.delay))
                return "delay: integer expected";
            }
            if (message.time != null && message.hasOwnProperty("time")) {
              if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                return "time: integer|Long expected";
            }
            if (message.uncertainty != null && message.hasOwnProperty("uncertainty")) {
              if (!$util.isInteger(message.uncertainty))
                return "uncertainty: integer expected";
            }
            return null;
          };
          StopTimeEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.transit_realtime.TripUpdate.StopTimeEvent)
              return object;
            var message = new $root.transit_realtime.TripUpdate.StopTimeEvent();
            if (object.delay != null)
              message.delay = object.delay | 0;
            if (object.time != null) {
              if ($util.Long)
                (message.time = $util.Long.fromValue(object.time)).unsigned = false;
              else if (typeof object.time === "string")
                message.time = parseInt(object.time, 10);
              else if (typeof object.time === "number")
                message.time = object.time;
              else if (typeof object.time === "object")
                message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            }
            if (object.uncertainty != null)
              message.uncertainty = object.uncertainty | 0;
            return message;
          };
          StopTimeEvent.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.delay = 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.time = options.longs === String ? "0" : 0;
              object.uncertainty = 0;
            }
            if (message.delay != null && message.hasOwnProperty("delay"))
              object.delay = message.delay;
            if (message.time != null && message.hasOwnProperty("time"))
              if (typeof message.time === "number")
                object.time = options.longs === String ? String(message.time) : message.time;
              else
                object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            if (message.uncertainty != null && message.hasOwnProperty("uncertainty"))
              object.uncertainty = message.uncertainty;
            return object;
          };
          StopTimeEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          StopTimeEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/transit_realtime.TripUpdate.StopTimeEvent";
          };
          return StopTimeEvent;
        }();
        TripUpdate.StopTimeUpdate = function() {
          function StopTimeUpdate(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          StopTimeUpdate.prototype.stopSequence = 0;
          StopTimeUpdate.prototype.stopId = "";
          StopTimeUpdate.prototype.arrival = null;
          StopTimeUpdate.prototype.departure = null;
          StopTimeUpdate.prototype.scheduleRelationship = 0;
          StopTimeUpdate.prototype.stopTimeProperties = null;
          StopTimeUpdate.create = function create(properties) {
            return new StopTimeUpdate(properties);
          };
          StopTimeUpdate.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.stopSequence != null && Object.hasOwnProperty.call(message, "stopSequence"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).uint32(message.stopSequence);
            if (message.arrival != null && Object.hasOwnProperty.call(message, "arrival"))
              $root.transit_realtime.TripUpdate.StopTimeEvent.encode(message.arrival, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            if (message.departure != null && Object.hasOwnProperty.call(message, "departure"))
              $root.transit_realtime.TripUpdate.StopTimeEvent.encode(message.departure, writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
            if (message.stopId != null && Object.hasOwnProperty.call(message, "stopId"))
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).string(message.stopId);
            if (message.scheduleRelationship != null && Object.hasOwnProperty.call(message, "scheduleRelationship"))
              writer.uint32(
                /* id 5, wireType 0 =*/
                40
              ).int32(message.scheduleRelationship);
            if (message.stopTimeProperties != null && Object.hasOwnProperty.call(message, "stopTimeProperties"))
              $root.transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.encode(message.stopTimeProperties, writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).fork()).ldelim();
            return writer;
          };
          StopTimeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          StopTimeUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.TripUpdate.StopTimeUpdate();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.stopSequence = reader.uint32();
                  break;
                }
                case 4: {
                  message.stopId = reader.string();
                  break;
                }
                case 2: {
                  message.arrival = $root.transit_realtime.TripUpdate.StopTimeEvent.decode(reader, reader.uint32());
                  break;
                }
                case 3: {
                  message.departure = $root.transit_realtime.TripUpdate.StopTimeEvent.decode(reader, reader.uint32());
                  break;
                }
                case 5: {
                  message.scheduleRelationship = reader.int32();
                  break;
                }
                case 6: {
                  message.stopTimeProperties = $root.transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          StopTimeUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          StopTimeUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.stopSequence != null && message.hasOwnProperty("stopSequence")) {
              if (!$util.isInteger(message.stopSequence))
                return "stopSequence: integer expected";
            }
            if (message.stopId != null && message.hasOwnProperty("stopId")) {
              if (!$util.isString(message.stopId))
                return "stopId: string expected";
            }
            if (message.arrival != null && message.hasOwnProperty("arrival")) {
              var error = $root.transit_realtime.TripUpdate.StopTimeEvent.verify(message.arrival);
              if (error)
                return "arrival." + error;
            }
            if (message.departure != null && message.hasOwnProperty("departure")) {
              var error = $root.transit_realtime.TripUpdate.StopTimeEvent.verify(message.departure);
              if (error)
                return "departure." + error;
            }
            if (message.scheduleRelationship != null && message.hasOwnProperty("scheduleRelationship"))
              switch (message.scheduleRelationship) {
                default:
                  return "scheduleRelationship: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
            if (message.stopTimeProperties != null && message.hasOwnProperty("stopTimeProperties")) {
              var error = $root.transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.verify(message.stopTimeProperties);
              if (error)
                return "stopTimeProperties." + error;
            }
            return null;
          };
          StopTimeUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.transit_realtime.TripUpdate.StopTimeUpdate)
              return object;
            var message = new $root.transit_realtime.TripUpdate.StopTimeUpdate();
            if (object.stopSequence != null)
              message.stopSequence = object.stopSequence >>> 0;
            if (object.stopId != null)
              message.stopId = String(object.stopId);
            if (object.arrival != null) {
              if (typeof object.arrival !== "object")
                throw TypeError(".transit_realtime.TripUpdate.StopTimeUpdate.arrival: object expected");
              message.arrival = $root.transit_realtime.TripUpdate.StopTimeEvent.fromObject(object.arrival);
            }
            if (object.departure != null) {
              if (typeof object.departure !== "object")
                throw TypeError(".transit_realtime.TripUpdate.StopTimeUpdate.departure: object expected");
              message.departure = $root.transit_realtime.TripUpdate.StopTimeEvent.fromObject(object.departure);
            }
            switch (object.scheduleRelationship) {
              default:
                if (typeof object.scheduleRelationship === "number") {
                  message.scheduleRelationship = object.scheduleRelationship;
                  break;
                }
                break;
              case "SCHEDULED":
              case 0:
                message.scheduleRelationship = 0;
                break;
              case "SKIPPED":
              case 1:
                message.scheduleRelationship = 1;
                break;
              case "NO_DATA":
              case 2:
                message.scheduleRelationship = 2;
                break;
              case "UNSCHEDULED":
              case 3:
                message.scheduleRelationship = 3;
                break;
            }
            if (object.stopTimeProperties != null) {
              if (typeof object.stopTimeProperties !== "object")
                throw TypeError(".transit_realtime.TripUpdate.StopTimeUpdate.stopTimeProperties: object expected");
              message.stopTimeProperties = $root.transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.fromObject(object.stopTimeProperties);
            }
            return message;
          };
          StopTimeUpdate.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.stopSequence = 0;
              object.arrival = null;
              object.departure = null;
              object.stopId = "";
              object.scheduleRelationship = options.enums === String ? "SCHEDULED" : 0;
              object.stopTimeProperties = null;
            }
            if (message.stopSequence != null && message.hasOwnProperty("stopSequence"))
              object.stopSequence = message.stopSequence;
            if (message.arrival != null && message.hasOwnProperty("arrival"))
              object.arrival = $root.transit_realtime.TripUpdate.StopTimeEvent.toObject(message.arrival, options);
            if (message.departure != null && message.hasOwnProperty("departure"))
              object.departure = $root.transit_realtime.TripUpdate.StopTimeEvent.toObject(message.departure, options);
            if (message.stopId != null && message.hasOwnProperty("stopId"))
              object.stopId = message.stopId;
            if (message.scheduleRelationship != null && message.hasOwnProperty("scheduleRelationship"))
              object.scheduleRelationship = options.enums === String ? $root.transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship[message.scheduleRelationship] === void 0 ? message.scheduleRelationship : $root.transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship[message.scheduleRelationship] : message.scheduleRelationship;
            if (message.stopTimeProperties != null && message.hasOwnProperty("stopTimeProperties"))
              object.stopTimeProperties = $root.transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.toObject(message.stopTimeProperties, options);
            return object;
          };
          StopTimeUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          StopTimeUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/transit_realtime.TripUpdate.StopTimeUpdate";
          };
          StopTimeUpdate.ScheduleRelationship = function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SCHEDULED"] = 0;
            values[valuesById[1] = "SKIPPED"] = 1;
            values[valuesById[2] = "NO_DATA"] = 2;
            values[valuesById[3] = "UNSCHEDULED"] = 3;
            return values;
          }();
          StopTimeUpdate.StopTimeProperties = function() {
            function StopTimeProperties(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            StopTimeProperties.prototype.assignedStopId = "";
            StopTimeProperties.create = function create(properties) {
              return new StopTimeProperties(properties);
            };
            StopTimeProperties.encode = function encode(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.assignedStopId != null && Object.hasOwnProperty.call(message, "assignedStopId"))
                writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.assignedStopId);
              return writer;
            };
            StopTimeProperties.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            StopTimeProperties.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.assignedStopId = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            StopTimeProperties.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            StopTimeProperties.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.assignedStopId != null && message.hasOwnProperty("assignedStopId")) {
                if (!$util.isString(message.assignedStopId))
                  return "assignedStopId: string expected";
              }
              return null;
            };
            StopTimeProperties.fromObject = function fromObject(object) {
              if (object instanceof $root.transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
                return object;
              var message = new $root.transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties();
              if (object.assignedStopId != null)
                message.assignedStopId = String(object.assignedStopId);
              return message;
            };
            StopTimeProperties.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults)
                object.assignedStopId = "";
              if (message.assignedStopId != null && message.hasOwnProperty("assignedStopId"))
                object.assignedStopId = message.assignedStopId;
              return object;
            };
            StopTimeProperties.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            StopTimeProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === void 0) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties";
            };
            return StopTimeProperties;
          }();
          return StopTimeUpdate;
        }();
        TripUpdate.TripProperties = function() {
          function TripProperties(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          TripProperties.prototype.tripId = "";
          TripProperties.prototype.startDate = "";
          TripProperties.prototype.startTime = "";
          TripProperties.create = function create(properties) {
            return new TripProperties(properties);
          };
          TripProperties.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.tripId != null && Object.hasOwnProperty.call(message, "tripId"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.tripId);
            if (message.startDate != null && Object.hasOwnProperty.call(message, "startDate"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.startDate);
            if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.startTime);
            return writer;
          };
          TripProperties.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          TripProperties.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.TripUpdate.TripProperties();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.tripId = reader.string();
                  break;
                }
                case 2: {
                  message.startDate = reader.string();
                  break;
                }
                case 3: {
                  message.startTime = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          TripProperties.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          TripProperties.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.tripId != null && message.hasOwnProperty("tripId")) {
              if (!$util.isString(message.tripId))
                return "tripId: string expected";
            }
            if (message.startDate != null && message.hasOwnProperty("startDate")) {
              if (!$util.isString(message.startDate))
                return "startDate: string expected";
            }
            if (message.startTime != null && message.hasOwnProperty("startTime")) {
              if (!$util.isString(message.startTime))
                return "startTime: string expected";
            }
            return null;
          };
          TripProperties.fromObject = function fromObject(object) {
            if (object instanceof $root.transit_realtime.TripUpdate.TripProperties)
              return object;
            var message = new $root.transit_realtime.TripUpdate.TripProperties();
            if (object.tripId != null)
              message.tripId = String(object.tripId);
            if (object.startDate != null)
              message.startDate = String(object.startDate);
            if (object.startTime != null)
              message.startTime = String(object.startTime);
            return message;
          };
          TripProperties.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.tripId = "";
              object.startDate = "";
              object.startTime = "";
            }
            if (message.tripId != null && message.hasOwnProperty("tripId"))
              object.tripId = message.tripId;
            if (message.startDate != null && message.hasOwnProperty("startDate"))
              object.startDate = message.startDate;
            if (message.startTime != null && message.hasOwnProperty("startTime"))
              object.startTime = message.startTime;
            return object;
          };
          TripProperties.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          TripProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/transit_realtime.TripUpdate.TripProperties";
          };
          return TripProperties;
        }();
        return TripUpdate;
      }();
      transit_realtime.VehiclePosition = function() {
        function VehiclePosition(properties) {
          this.multiCarriageDetails = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        VehiclePosition.prototype.trip = null;
        VehiclePosition.prototype.vehicle = null;
        VehiclePosition.prototype.position = null;
        VehiclePosition.prototype.currentStopSequence = 0;
        VehiclePosition.prototype.stopId = "";
        VehiclePosition.prototype.currentStatus = 2;
        VehiclePosition.prototype.timestamp = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        VehiclePosition.prototype.congestionLevel = 0;
        VehiclePosition.prototype.occupancyStatus = 0;
        VehiclePosition.prototype.occupancyPercentage = 0;
        VehiclePosition.prototype.multiCarriageDetails = $util.emptyArray;
        VehiclePosition.create = function create(properties) {
          return new VehiclePosition(properties);
        };
        VehiclePosition.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.trip != null && Object.hasOwnProperty.call(message, "trip"))
            $root.transit_realtime.TripDescriptor.encode(message.trip, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.position != null && Object.hasOwnProperty.call(message, "position"))
            $root.transit_realtime.Position.encode(message.position, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.currentStopSequence != null && Object.hasOwnProperty.call(message, "currentStopSequence"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).uint32(message.currentStopSequence);
          if (message.currentStatus != null && Object.hasOwnProperty.call(message, "currentStatus"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.currentStatus);
          if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
            writer.uint32(
              /* id 5, wireType 0 =*/
              40
            ).uint64(message.timestamp);
          if (message.congestionLevel != null && Object.hasOwnProperty.call(message, "congestionLevel"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).int32(message.congestionLevel);
          if (message.stopId != null && Object.hasOwnProperty.call(message, "stopId"))
            writer.uint32(
              /* id 7, wireType 2 =*/
              58
            ).string(message.stopId);
          if (message.vehicle != null && Object.hasOwnProperty.call(message, "vehicle"))
            $root.transit_realtime.VehicleDescriptor.encode(message.vehicle, writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).fork()).ldelim();
          if (message.occupancyStatus != null && Object.hasOwnProperty.call(message, "occupancyStatus"))
            writer.uint32(
              /* id 9, wireType 0 =*/
              72
            ).int32(message.occupancyStatus);
          if (message.occupancyPercentage != null && Object.hasOwnProperty.call(message, "occupancyPercentage"))
            writer.uint32(
              /* id 10, wireType 0 =*/
              80
            ).uint32(message.occupancyPercentage);
          if (message.multiCarriageDetails != null && message.multiCarriageDetails.length)
            for (var i = 0; i < message.multiCarriageDetails.length; ++i)
              $root.transit_realtime.VehiclePosition.CarriageDetails.encode(message.multiCarriageDetails[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          return writer;
        };
        VehiclePosition.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        VehiclePosition.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.VehiclePosition();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.trip = $root.transit_realtime.TripDescriptor.decode(reader, reader.uint32());
                break;
              }
              case 8: {
                message.vehicle = $root.transit_realtime.VehicleDescriptor.decode(reader, reader.uint32());
                break;
              }
              case 2: {
                message.position = $root.transit_realtime.Position.decode(reader, reader.uint32());
                break;
              }
              case 3: {
                message.currentStopSequence = reader.uint32();
                break;
              }
              case 7: {
                message.stopId = reader.string();
                break;
              }
              case 4: {
                message.currentStatus = reader.int32();
                break;
              }
              case 5: {
                message.timestamp = reader.uint64();
                break;
              }
              case 6: {
                message.congestionLevel = reader.int32();
                break;
              }
              case 9: {
                message.occupancyStatus = reader.int32();
                break;
              }
              case 10: {
                message.occupancyPercentage = reader.uint32();
                break;
              }
              case 11: {
                if (!(message.multiCarriageDetails && message.multiCarriageDetails.length))
                  message.multiCarriageDetails = [];
                message.multiCarriageDetails.push($root.transit_realtime.VehiclePosition.CarriageDetails.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        VehiclePosition.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        VehiclePosition.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.trip != null && message.hasOwnProperty("trip")) {
            var error = $root.transit_realtime.TripDescriptor.verify(message.trip);
            if (error)
              return "trip." + error;
          }
          if (message.vehicle != null && message.hasOwnProperty("vehicle")) {
            var error = $root.transit_realtime.VehicleDescriptor.verify(message.vehicle);
            if (error)
              return "vehicle." + error;
          }
          if (message.position != null && message.hasOwnProperty("position")) {
            var error = $root.transit_realtime.Position.verify(message.position);
            if (error)
              return "position." + error;
          }
          if (message.currentStopSequence != null && message.hasOwnProperty("currentStopSequence")) {
            if (!$util.isInteger(message.currentStopSequence))
              return "currentStopSequence: integer expected";
          }
          if (message.stopId != null && message.hasOwnProperty("stopId")) {
            if (!$util.isString(message.stopId))
              return "stopId: string expected";
          }
          if (message.currentStatus != null && message.hasOwnProperty("currentStatus"))
            switch (message.currentStatus) {
              default:
                return "currentStatus: enum value expected";
              case 0:
              case 1:
              case 2:
                break;
            }
          if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
            if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
              return "timestamp: integer|Long expected";
          }
          if (message.congestionLevel != null && message.hasOwnProperty("congestionLevel"))
            switch (message.congestionLevel) {
              default:
                return "congestionLevel: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
                break;
            }
          if (message.occupancyStatus != null && message.hasOwnProperty("occupancyStatus"))
            switch (message.occupancyStatus) {
              default:
                return "occupancyStatus: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
                break;
            }
          if (message.occupancyPercentage != null && message.hasOwnProperty("occupancyPercentage")) {
            if (!$util.isInteger(message.occupancyPercentage))
              return "occupancyPercentage: integer expected";
          }
          if (message.multiCarriageDetails != null && message.hasOwnProperty("multiCarriageDetails")) {
            if (!Array.isArray(message.multiCarriageDetails))
              return "multiCarriageDetails: array expected";
            for (var i = 0; i < message.multiCarriageDetails.length; ++i) {
              var error = $root.transit_realtime.VehiclePosition.CarriageDetails.verify(message.multiCarriageDetails[i]);
              if (error)
                return "multiCarriageDetails." + error;
            }
          }
          return null;
        };
        VehiclePosition.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.VehiclePosition)
            return object;
          var message = new $root.transit_realtime.VehiclePosition();
          if (object.trip != null) {
            if (typeof object.trip !== "object")
              throw TypeError(".transit_realtime.VehiclePosition.trip: object expected");
            message.trip = $root.transit_realtime.TripDescriptor.fromObject(object.trip);
          }
          if (object.vehicle != null) {
            if (typeof object.vehicle !== "object")
              throw TypeError(".transit_realtime.VehiclePosition.vehicle: object expected");
            message.vehicle = $root.transit_realtime.VehicleDescriptor.fromObject(object.vehicle);
          }
          if (object.position != null) {
            if (typeof object.position !== "object")
              throw TypeError(".transit_realtime.VehiclePosition.position: object expected");
            message.position = $root.transit_realtime.Position.fromObject(object.position);
          }
          if (object.currentStopSequence != null)
            message.currentStopSequence = object.currentStopSequence >>> 0;
          if (object.stopId != null)
            message.stopId = String(object.stopId);
          switch (object.currentStatus) {
            case "INCOMING_AT":
            case 0:
              message.currentStatus = 0;
              break;
            case "STOPPED_AT":
            case 1:
              message.currentStatus = 1;
              break;
            default:
              if (typeof object.currentStatus === "number") {
                message.currentStatus = object.currentStatus;
                break;
              }
              break;
            case "IN_TRANSIT_TO":
            case 2:
              message.currentStatus = 2;
              break;
          }
          if (object.timestamp != null) {
            if ($util.Long)
              (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
            else if (typeof object.timestamp === "string")
              message.timestamp = parseInt(object.timestamp, 10);
            else if (typeof object.timestamp === "number")
              message.timestamp = object.timestamp;
            else if (typeof object.timestamp === "object")
              message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
          }
          switch (object.congestionLevel) {
            default:
              if (typeof object.congestionLevel === "number") {
                message.congestionLevel = object.congestionLevel;
                break;
              }
              break;
            case "UNKNOWN_CONGESTION_LEVEL":
            case 0:
              message.congestionLevel = 0;
              break;
            case "RUNNING_SMOOTHLY":
            case 1:
              message.congestionLevel = 1;
              break;
            case "STOP_AND_GO":
            case 2:
              message.congestionLevel = 2;
              break;
            case "CONGESTION":
            case 3:
              message.congestionLevel = 3;
              break;
            case "SEVERE_CONGESTION":
            case 4:
              message.congestionLevel = 4;
              break;
          }
          switch (object.occupancyStatus) {
            default:
              if (typeof object.occupancyStatus === "number") {
                message.occupancyStatus = object.occupancyStatus;
                break;
              }
              break;
            case "EMPTY":
            case 0:
              message.occupancyStatus = 0;
              break;
            case "MANY_SEATS_AVAILABLE":
            case 1:
              message.occupancyStatus = 1;
              break;
            case "FEW_SEATS_AVAILABLE":
            case 2:
              message.occupancyStatus = 2;
              break;
            case "STANDING_ROOM_ONLY":
            case 3:
              message.occupancyStatus = 3;
              break;
            case "CRUSHED_STANDING_ROOM_ONLY":
            case 4:
              message.occupancyStatus = 4;
              break;
            case "FULL":
            case 5:
              message.occupancyStatus = 5;
              break;
            case "NOT_ACCEPTING_PASSENGERS":
            case 6:
              message.occupancyStatus = 6;
              break;
            case "NO_DATA_AVAILABLE":
            case 7:
              message.occupancyStatus = 7;
              break;
            case "NOT_BOARDABLE":
            case 8:
              message.occupancyStatus = 8;
              break;
          }
          if (object.occupancyPercentage != null)
            message.occupancyPercentage = object.occupancyPercentage >>> 0;
          if (object.multiCarriageDetails) {
            if (!Array.isArray(object.multiCarriageDetails))
              throw TypeError(".transit_realtime.VehiclePosition.multiCarriageDetails: array expected");
            message.multiCarriageDetails = [];
            for (var i = 0; i < object.multiCarriageDetails.length; ++i) {
              if (typeof object.multiCarriageDetails[i] !== "object")
                throw TypeError(".transit_realtime.VehiclePosition.multiCarriageDetails: object expected");
              message.multiCarriageDetails[i] = $root.transit_realtime.VehiclePosition.CarriageDetails.fromObject(object.multiCarriageDetails[i]);
            }
          }
          return message;
        };
        VehiclePosition.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.multiCarriageDetails = [];
          if (options.defaults) {
            object.trip = null;
            object.position = null;
            object.currentStopSequence = 0;
            object.currentStatus = options.enums === String ? "IN_TRANSIT_TO" : 2;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.timestamp = options.longs === String ? "0" : 0;
            object.congestionLevel = options.enums === String ? "UNKNOWN_CONGESTION_LEVEL" : 0;
            object.stopId = "";
            object.vehicle = null;
            object.occupancyStatus = options.enums === String ? "EMPTY" : 0;
            object.occupancyPercentage = 0;
          }
          if (message.trip != null && message.hasOwnProperty("trip"))
            object.trip = $root.transit_realtime.TripDescriptor.toObject(message.trip, options);
          if (message.position != null && message.hasOwnProperty("position"))
            object.position = $root.transit_realtime.Position.toObject(message.position, options);
          if (message.currentStopSequence != null && message.hasOwnProperty("currentStopSequence"))
            object.currentStopSequence = message.currentStopSequence;
          if (message.currentStatus != null && message.hasOwnProperty("currentStatus"))
            object.currentStatus = options.enums === String ? $root.transit_realtime.VehiclePosition.VehicleStopStatus[message.currentStatus] === void 0 ? message.currentStatus : $root.transit_realtime.VehiclePosition.VehicleStopStatus[message.currentStatus] : message.currentStatus;
          if (message.timestamp != null && message.hasOwnProperty("timestamp"))
            if (typeof message.timestamp === "number")
              object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
            else
              object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
          if (message.congestionLevel != null && message.hasOwnProperty("congestionLevel"))
            object.congestionLevel = options.enums === String ? $root.transit_realtime.VehiclePosition.CongestionLevel[message.congestionLevel] === void 0 ? message.congestionLevel : $root.transit_realtime.VehiclePosition.CongestionLevel[message.congestionLevel] : message.congestionLevel;
          if (message.stopId != null && message.hasOwnProperty("stopId"))
            object.stopId = message.stopId;
          if (message.vehicle != null && message.hasOwnProperty("vehicle"))
            object.vehicle = $root.transit_realtime.VehicleDescriptor.toObject(message.vehicle, options);
          if (message.occupancyStatus != null && message.hasOwnProperty("occupancyStatus"))
            object.occupancyStatus = options.enums === String ? $root.transit_realtime.VehiclePosition.OccupancyStatus[message.occupancyStatus] === void 0 ? message.occupancyStatus : $root.transit_realtime.VehiclePosition.OccupancyStatus[message.occupancyStatus] : message.occupancyStatus;
          if (message.occupancyPercentage != null && message.hasOwnProperty("occupancyPercentage"))
            object.occupancyPercentage = message.occupancyPercentage;
          if (message.multiCarriageDetails && message.multiCarriageDetails.length) {
            object.multiCarriageDetails = [];
            for (var j = 0; j < message.multiCarriageDetails.length; ++j)
              object.multiCarriageDetails[j] = $root.transit_realtime.VehiclePosition.CarriageDetails.toObject(message.multiCarriageDetails[j], options);
          }
          return object;
        };
        VehiclePosition.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        VehiclePosition.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.VehiclePosition";
        };
        VehiclePosition.VehicleStopStatus = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "INCOMING_AT"] = 0;
          values[valuesById[1] = "STOPPED_AT"] = 1;
          values[valuesById[2] = "IN_TRANSIT_TO"] = 2;
          return values;
        }();
        VehiclePosition.CongestionLevel = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNKNOWN_CONGESTION_LEVEL"] = 0;
          values[valuesById[1] = "RUNNING_SMOOTHLY"] = 1;
          values[valuesById[2] = "STOP_AND_GO"] = 2;
          values[valuesById[3] = "CONGESTION"] = 3;
          values[valuesById[4] = "SEVERE_CONGESTION"] = 4;
          return values;
        }();
        VehiclePosition.OccupancyStatus = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "EMPTY"] = 0;
          values[valuesById[1] = "MANY_SEATS_AVAILABLE"] = 1;
          values[valuesById[2] = "FEW_SEATS_AVAILABLE"] = 2;
          values[valuesById[3] = "STANDING_ROOM_ONLY"] = 3;
          values[valuesById[4] = "CRUSHED_STANDING_ROOM_ONLY"] = 4;
          values[valuesById[5] = "FULL"] = 5;
          values[valuesById[6] = "NOT_ACCEPTING_PASSENGERS"] = 6;
          values[valuesById[7] = "NO_DATA_AVAILABLE"] = 7;
          values[valuesById[8] = "NOT_BOARDABLE"] = 8;
          return values;
        }();
        VehiclePosition.CarriageDetails = function() {
          function CarriageDetails(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          CarriageDetails.prototype.id = "";
          CarriageDetails.prototype.label = "";
          CarriageDetails.prototype.occupancyStatus = 7;
          CarriageDetails.prototype.occupancyPercentage = -1;
          CarriageDetails.prototype.carriageSequence = 0;
          CarriageDetails.create = function create(properties) {
            return new CarriageDetails(properties);
          };
          CarriageDetails.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.id);
            if (message.label != null && Object.hasOwnProperty.call(message, "label"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.label);
            if (message.occupancyStatus != null && Object.hasOwnProperty.call(message, "occupancyStatus"))
              writer.uint32(
                /* id 3, wireType 0 =*/
                24
              ).int32(message.occupancyStatus);
            if (message.occupancyPercentage != null && Object.hasOwnProperty.call(message, "occupancyPercentage"))
              writer.uint32(
                /* id 4, wireType 0 =*/
                32
              ).int32(message.occupancyPercentage);
            if (message.carriageSequence != null && Object.hasOwnProperty.call(message, "carriageSequence"))
              writer.uint32(
                /* id 5, wireType 0 =*/
                40
              ).uint32(message.carriageSequence);
            return writer;
          };
          CarriageDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          CarriageDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.VehiclePosition.CarriageDetails();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.id = reader.string();
                  break;
                }
                case 2: {
                  message.label = reader.string();
                  break;
                }
                case 3: {
                  message.occupancyStatus = reader.int32();
                  break;
                }
                case 4: {
                  message.occupancyPercentage = reader.int32();
                  break;
                }
                case 5: {
                  message.carriageSequence = reader.uint32();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          CarriageDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          CarriageDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
              if (!$util.isString(message.id))
                return "id: string expected";
            }
            if (message.label != null && message.hasOwnProperty("label")) {
              if (!$util.isString(message.label))
                return "label: string expected";
            }
            if (message.occupancyStatus != null && message.hasOwnProperty("occupancyStatus"))
              switch (message.occupancyStatus) {
                default:
                  return "occupancyStatus: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                  break;
              }
            if (message.occupancyPercentage != null && message.hasOwnProperty("occupancyPercentage")) {
              if (!$util.isInteger(message.occupancyPercentage))
                return "occupancyPercentage: integer expected";
            }
            if (message.carriageSequence != null && message.hasOwnProperty("carriageSequence")) {
              if (!$util.isInteger(message.carriageSequence))
                return "carriageSequence: integer expected";
            }
            return null;
          };
          CarriageDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.transit_realtime.VehiclePosition.CarriageDetails)
              return object;
            var message = new $root.transit_realtime.VehiclePosition.CarriageDetails();
            if (object.id != null)
              message.id = String(object.id);
            if (object.label != null)
              message.label = String(object.label);
            switch (object.occupancyStatus) {
              case "EMPTY":
              case 0:
                message.occupancyStatus = 0;
                break;
              case "MANY_SEATS_AVAILABLE":
              case 1:
                message.occupancyStatus = 1;
                break;
              case "FEW_SEATS_AVAILABLE":
              case 2:
                message.occupancyStatus = 2;
                break;
              case "STANDING_ROOM_ONLY":
              case 3:
                message.occupancyStatus = 3;
                break;
              case "CRUSHED_STANDING_ROOM_ONLY":
              case 4:
                message.occupancyStatus = 4;
                break;
              case "FULL":
              case 5:
                message.occupancyStatus = 5;
                break;
              case "NOT_ACCEPTING_PASSENGERS":
              case 6:
                message.occupancyStatus = 6;
                break;
              default:
                if (typeof object.occupancyStatus === "number") {
                  message.occupancyStatus = object.occupancyStatus;
                  break;
                }
                break;
              case "NO_DATA_AVAILABLE":
              case 7:
                message.occupancyStatus = 7;
                break;
              case "NOT_BOARDABLE":
              case 8:
                message.occupancyStatus = 8;
                break;
            }
            if (object.occupancyPercentage != null)
              message.occupancyPercentage = object.occupancyPercentage | 0;
            if (object.carriageSequence != null)
              message.carriageSequence = object.carriageSequence >>> 0;
            return message;
          };
          CarriageDetails.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.id = "";
              object.label = "";
              object.occupancyStatus = options.enums === String ? "NO_DATA_AVAILABLE" : 7;
              object.occupancyPercentage = -1;
              object.carriageSequence = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (message.occupancyStatus != null && message.hasOwnProperty("occupancyStatus"))
              object.occupancyStatus = options.enums === String ? $root.transit_realtime.VehiclePosition.OccupancyStatus[message.occupancyStatus] === void 0 ? message.occupancyStatus : $root.transit_realtime.VehiclePosition.OccupancyStatus[message.occupancyStatus] : message.occupancyStatus;
            if (message.occupancyPercentage != null && message.hasOwnProperty("occupancyPercentage"))
              object.occupancyPercentage = message.occupancyPercentage;
            if (message.carriageSequence != null && message.hasOwnProperty("carriageSequence"))
              object.carriageSequence = message.carriageSequence;
            return object;
          };
          CarriageDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          CarriageDetails.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/transit_realtime.VehiclePosition.CarriageDetails";
          };
          return CarriageDetails;
        }();
        return VehiclePosition;
      }();
      transit_realtime.Alert = function() {
        function Alert(properties) {
          this.activePeriod = [];
          this.informedEntity = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Alert.prototype.activePeriod = $util.emptyArray;
        Alert.prototype.informedEntity = $util.emptyArray;
        Alert.prototype.cause = 1;
        Alert.prototype.effect = 8;
        Alert.prototype.url = null;
        Alert.prototype.headerText = null;
        Alert.prototype.descriptionText = null;
        Alert.prototype.ttsHeaderText = null;
        Alert.prototype.ttsDescriptionText = null;
        Alert.prototype.severityLevel = 1;
        Alert.create = function create(properties) {
          return new Alert(properties);
        };
        Alert.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.activePeriod != null && message.activePeriod.length)
            for (var i = 0; i < message.activePeriod.length; ++i)
              $root.transit_realtime.TimeRange.encode(message.activePeriod[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          if (message.informedEntity != null && message.informedEntity.length)
            for (var i = 0; i < message.informedEntity.length; ++i)
              $root.transit_realtime.EntitySelector.encode(message.informedEntity[i], writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
          if (message.cause != null && Object.hasOwnProperty.call(message, "cause"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).int32(message.cause);
          if (message.effect != null && Object.hasOwnProperty.call(message, "effect"))
            writer.uint32(
              /* id 7, wireType 0 =*/
              56
            ).int32(message.effect);
          if (message.url != null && Object.hasOwnProperty.call(message, "url"))
            $root.transit_realtime.TranslatedString.encode(message.url, writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).fork()).ldelim();
          if (message.headerText != null && Object.hasOwnProperty.call(message, "headerText"))
            $root.transit_realtime.TranslatedString.encode(message.headerText, writer.uint32(
              /* id 10, wireType 2 =*/
              82
            ).fork()).ldelim();
          if (message.descriptionText != null && Object.hasOwnProperty.call(message, "descriptionText"))
            $root.transit_realtime.TranslatedString.encode(message.descriptionText, writer.uint32(
              /* id 11, wireType 2 =*/
              90
            ).fork()).ldelim();
          if (message.ttsHeaderText != null && Object.hasOwnProperty.call(message, "ttsHeaderText"))
            $root.transit_realtime.TranslatedString.encode(message.ttsHeaderText, writer.uint32(
              /* id 12, wireType 2 =*/
              98
            ).fork()).ldelim();
          if (message.ttsDescriptionText != null && Object.hasOwnProperty.call(message, "ttsDescriptionText"))
            $root.transit_realtime.TranslatedString.encode(message.ttsDescriptionText, writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).fork()).ldelim();
          if (message.severityLevel != null && Object.hasOwnProperty.call(message, "severityLevel"))
            writer.uint32(
              /* id 14, wireType 0 =*/
              112
            ).int32(message.severityLevel);
          return writer;
        };
        Alert.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Alert.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.Alert();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.activePeriod && message.activePeriod.length))
                  message.activePeriod = [];
                message.activePeriod.push($root.transit_realtime.TimeRange.decode(reader, reader.uint32()));
                break;
              }
              case 5: {
                if (!(message.informedEntity && message.informedEntity.length))
                  message.informedEntity = [];
                message.informedEntity.push($root.transit_realtime.EntitySelector.decode(reader, reader.uint32()));
                break;
              }
              case 6: {
                message.cause = reader.int32();
                break;
              }
              case 7: {
                message.effect = reader.int32();
                break;
              }
              case 8: {
                message.url = $root.transit_realtime.TranslatedString.decode(reader, reader.uint32());
                break;
              }
              case 10: {
                message.headerText = $root.transit_realtime.TranslatedString.decode(reader, reader.uint32());
                break;
              }
              case 11: {
                message.descriptionText = $root.transit_realtime.TranslatedString.decode(reader, reader.uint32());
                break;
              }
              case 12: {
                message.ttsHeaderText = $root.transit_realtime.TranslatedString.decode(reader, reader.uint32());
                break;
              }
              case 13: {
                message.ttsDescriptionText = $root.transit_realtime.TranslatedString.decode(reader, reader.uint32());
                break;
              }
              case 14: {
                message.severityLevel = reader.int32();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        Alert.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Alert.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.activePeriod != null && message.hasOwnProperty("activePeriod")) {
            if (!Array.isArray(message.activePeriod))
              return "activePeriod: array expected";
            for (var i = 0; i < message.activePeriod.length; ++i) {
              var error = $root.transit_realtime.TimeRange.verify(message.activePeriod[i]);
              if (error)
                return "activePeriod." + error;
            }
          }
          if (message.informedEntity != null && message.hasOwnProperty("informedEntity")) {
            if (!Array.isArray(message.informedEntity))
              return "informedEntity: array expected";
            for (var i = 0; i < message.informedEntity.length; ++i) {
              var error = $root.transit_realtime.EntitySelector.verify(message.informedEntity[i]);
              if (error)
                return "informedEntity." + error;
            }
          }
          if (message.cause != null && message.hasOwnProperty("cause"))
            switch (message.cause) {
              default:
                return "cause: enum value expected";
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
              case 12:
                break;
            }
          if (message.effect != null && message.hasOwnProperty("effect"))
            switch (message.effect) {
              default:
                return "effect: enum value expected";
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
                break;
            }
          if (message.url != null && message.hasOwnProperty("url")) {
            var error = $root.transit_realtime.TranslatedString.verify(message.url);
            if (error)
              return "url." + error;
          }
          if (message.headerText != null && message.hasOwnProperty("headerText")) {
            var error = $root.transit_realtime.TranslatedString.verify(message.headerText);
            if (error)
              return "headerText." + error;
          }
          if (message.descriptionText != null && message.hasOwnProperty("descriptionText")) {
            var error = $root.transit_realtime.TranslatedString.verify(message.descriptionText);
            if (error)
              return "descriptionText." + error;
          }
          if (message.ttsHeaderText != null && message.hasOwnProperty("ttsHeaderText")) {
            var error = $root.transit_realtime.TranslatedString.verify(message.ttsHeaderText);
            if (error)
              return "ttsHeaderText." + error;
          }
          if (message.ttsDescriptionText != null && message.hasOwnProperty("ttsDescriptionText")) {
            var error = $root.transit_realtime.TranslatedString.verify(message.ttsDescriptionText);
            if (error)
              return "ttsDescriptionText." + error;
          }
          if (message.severityLevel != null && message.hasOwnProperty("severityLevel"))
            switch (message.severityLevel) {
              default:
                return "severityLevel: enum value expected";
              case 1:
              case 2:
              case 3:
              case 4:
                break;
            }
          return null;
        };
        Alert.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.Alert)
            return object;
          var message = new $root.transit_realtime.Alert();
          if (object.activePeriod) {
            if (!Array.isArray(object.activePeriod))
              throw TypeError(".transit_realtime.Alert.activePeriod: array expected");
            message.activePeriod = [];
            for (var i = 0; i < object.activePeriod.length; ++i) {
              if (typeof object.activePeriod[i] !== "object")
                throw TypeError(".transit_realtime.Alert.activePeriod: object expected");
              message.activePeriod[i] = $root.transit_realtime.TimeRange.fromObject(object.activePeriod[i]);
            }
          }
          if (object.informedEntity) {
            if (!Array.isArray(object.informedEntity))
              throw TypeError(".transit_realtime.Alert.informedEntity: array expected");
            message.informedEntity = [];
            for (var i = 0; i < object.informedEntity.length; ++i) {
              if (typeof object.informedEntity[i] !== "object")
                throw TypeError(".transit_realtime.Alert.informedEntity: object expected");
              message.informedEntity[i] = $root.transit_realtime.EntitySelector.fromObject(object.informedEntity[i]);
            }
          }
          switch (object.cause) {
            default:
              if (typeof object.cause === "number") {
                message.cause = object.cause;
                break;
              }
              break;
            case "UNKNOWN_CAUSE":
            case 1:
              message.cause = 1;
              break;
            case "OTHER_CAUSE":
            case 2:
              message.cause = 2;
              break;
            case "TECHNICAL_PROBLEM":
            case 3:
              message.cause = 3;
              break;
            case "STRIKE":
            case 4:
              message.cause = 4;
              break;
            case "DEMONSTRATION":
            case 5:
              message.cause = 5;
              break;
            case "ACCIDENT":
            case 6:
              message.cause = 6;
              break;
            case "HOLIDAY":
            case 7:
              message.cause = 7;
              break;
            case "WEATHER":
            case 8:
              message.cause = 8;
              break;
            case "MAINTENANCE":
            case 9:
              message.cause = 9;
              break;
            case "CONSTRUCTION":
            case 10:
              message.cause = 10;
              break;
            case "POLICE_ACTIVITY":
            case 11:
              message.cause = 11;
              break;
            case "MEDICAL_EMERGENCY":
            case 12:
              message.cause = 12;
              break;
          }
          switch (object.effect) {
            case "NO_SERVICE":
            case 1:
              message.effect = 1;
              break;
            case "REDUCED_SERVICE":
            case 2:
              message.effect = 2;
              break;
            case "SIGNIFICANT_DELAYS":
            case 3:
              message.effect = 3;
              break;
            case "DETOUR":
            case 4:
              message.effect = 4;
              break;
            case "ADDITIONAL_SERVICE":
            case 5:
              message.effect = 5;
              break;
            case "MODIFIED_SERVICE":
            case 6:
              message.effect = 6;
              break;
            case "OTHER_EFFECT":
            case 7:
              message.effect = 7;
              break;
            default:
              if (typeof object.effect === "number") {
                message.effect = object.effect;
                break;
              }
              break;
            case "UNKNOWN_EFFECT":
            case 8:
              message.effect = 8;
              break;
            case "STOP_MOVED":
            case 9:
              message.effect = 9;
              break;
            case "NO_EFFECT":
            case 10:
              message.effect = 10;
              break;
            case "ACCESSIBILITY_ISSUE":
            case 11:
              message.effect = 11;
              break;
          }
          if (object.url != null) {
            if (typeof object.url !== "object")
              throw TypeError(".transit_realtime.Alert.url: object expected");
            message.url = $root.transit_realtime.TranslatedString.fromObject(object.url);
          }
          if (object.headerText != null) {
            if (typeof object.headerText !== "object")
              throw TypeError(".transit_realtime.Alert.headerText: object expected");
            message.headerText = $root.transit_realtime.TranslatedString.fromObject(object.headerText);
          }
          if (object.descriptionText != null) {
            if (typeof object.descriptionText !== "object")
              throw TypeError(".transit_realtime.Alert.descriptionText: object expected");
            message.descriptionText = $root.transit_realtime.TranslatedString.fromObject(object.descriptionText);
          }
          if (object.ttsHeaderText != null) {
            if (typeof object.ttsHeaderText !== "object")
              throw TypeError(".transit_realtime.Alert.ttsHeaderText: object expected");
            message.ttsHeaderText = $root.transit_realtime.TranslatedString.fromObject(object.ttsHeaderText);
          }
          if (object.ttsDescriptionText != null) {
            if (typeof object.ttsDescriptionText !== "object")
              throw TypeError(".transit_realtime.Alert.ttsDescriptionText: object expected");
            message.ttsDescriptionText = $root.transit_realtime.TranslatedString.fromObject(object.ttsDescriptionText);
          }
          switch (object.severityLevel) {
            default:
              if (typeof object.severityLevel === "number") {
                message.severityLevel = object.severityLevel;
                break;
              }
              break;
            case "UNKNOWN_SEVERITY":
            case 1:
              message.severityLevel = 1;
              break;
            case "INFO":
            case 2:
              message.severityLevel = 2;
              break;
            case "WARNING":
            case 3:
              message.severityLevel = 3;
              break;
            case "SEVERE":
            case 4:
              message.severityLevel = 4;
              break;
          }
          return message;
        };
        Alert.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.activePeriod = [];
            object.informedEntity = [];
          }
          if (options.defaults) {
            object.cause = options.enums === String ? "UNKNOWN_CAUSE" : 1;
            object.effect = options.enums === String ? "UNKNOWN_EFFECT" : 8;
            object.url = null;
            object.headerText = null;
            object.descriptionText = null;
            object.ttsHeaderText = null;
            object.ttsDescriptionText = null;
            object.severityLevel = options.enums === String ? "UNKNOWN_SEVERITY" : 1;
          }
          if (message.activePeriod && message.activePeriod.length) {
            object.activePeriod = [];
            for (var j = 0; j < message.activePeriod.length; ++j)
              object.activePeriod[j] = $root.transit_realtime.TimeRange.toObject(message.activePeriod[j], options);
          }
          if (message.informedEntity && message.informedEntity.length) {
            object.informedEntity = [];
            for (var j = 0; j < message.informedEntity.length; ++j)
              object.informedEntity[j] = $root.transit_realtime.EntitySelector.toObject(message.informedEntity[j], options);
          }
          if (message.cause != null && message.hasOwnProperty("cause"))
            object.cause = options.enums === String ? $root.transit_realtime.Alert.Cause[message.cause] === void 0 ? message.cause : $root.transit_realtime.Alert.Cause[message.cause] : message.cause;
          if (message.effect != null && message.hasOwnProperty("effect"))
            object.effect = options.enums === String ? $root.transit_realtime.Alert.Effect[message.effect] === void 0 ? message.effect : $root.transit_realtime.Alert.Effect[message.effect] : message.effect;
          if (message.url != null && message.hasOwnProperty("url"))
            object.url = $root.transit_realtime.TranslatedString.toObject(message.url, options);
          if (message.headerText != null && message.hasOwnProperty("headerText"))
            object.headerText = $root.transit_realtime.TranslatedString.toObject(message.headerText, options);
          if (message.descriptionText != null && message.hasOwnProperty("descriptionText"))
            object.descriptionText = $root.transit_realtime.TranslatedString.toObject(message.descriptionText, options);
          if (message.ttsHeaderText != null && message.hasOwnProperty("ttsHeaderText"))
            object.ttsHeaderText = $root.transit_realtime.TranslatedString.toObject(message.ttsHeaderText, options);
          if (message.ttsDescriptionText != null && message.hasOwnProperty("ttsDescriptionText"))
            object.ttsDescriptionText = $root.transit_realtime.TranslatedString.toObject(message.ttsDescriptionText, options);
          if (message.severityLevel != null && message.hasOwnProperty("severityLevel"))
            object.severityLevel = options.enums === String ? $root.transit_realtime.Alert.SeverityLevel[message.severityLevel] === void 0 ? message.severityLevel : $root.transit_realtime.Alert.SeverityLevel[message.severityLevel] : message.severityLevel;
          return object;
        };
        Alert.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Alert.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.Alert";
        };
        Alert.Cause = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[1] = "UNKNOWN_CAUSE"] = 1;
          values[valuesById[2] = "OTHER_CAUSE"] = 2;
          values[valuesById[3] = "TECHNICAL_PROBLEM"] = 3;
          values[valuesById[4] = "STRIKE"] = 4;
          values[valuesById[5] = "DEMONSTRATION"] = 5;
          values[valuesById[6] = "ACCIDENT"] = 6;
          values[valuesById[7] = "HOLIDAY"] = 7;
          values[valuesById[8] = "WEATHER"] = 8;
          values[valuesById[9] = "MAINTENANCE"] = 9;
          values[valuesById[10] = "CONSTRUCTION"] = 10;
          values[valuesById[11] = "POLICE_ACTIVITY"] = 11;
          values[valuesById[12] = "MEDICAL_EMERGENCY"] = 12;
          return values;
        }();
        Alert.Effect = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[1] = "NO_SERVICE"] = 1;
          values[valuesById[2] = "REDUCED_SERVICE"] = 2;
          values[valuesById[3] = "SIGNIFICANT_DELAYS"] = 3;
          values[valuesById[4] = "DETOUR"] = 4;
          values[valuesById[5] = "ADDITIONAL_SERVICE"] = 5;
          values[valuesById[6] = "MODIFIED_SERVICE"] = 6;
          values[valuesById[7] = "OTHER_EFFECT"] = 7;
          values[valuesById[8] = "UNKNOWN_EFFECT"] = 8;
          values[valuesById[9] = "STOP_MOVED"] = 9;
          values[valuesById[10] = "NO_EFFECT"] = 10;
          values[valuesById[11] = "ACCESSIBILITY_ISSUE"] = 11;
          return values;
        }();
        Alert.SeverityLevel = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[1] = "UNKNOWN_SEVERITY"] = 1;
          values[valuesById[2] = "INFO"] = 2;
          values[valuesById[3] = "WARNING"] = 3;
          values[valuesById[4] = "SEVERE"] = 4;
          return values;
        }();
        return Alert;
      }();
      transit_realtime.TimeRange = function() {
        function TimeRange(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TimeRange.prototype.start = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TimeRange.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        TimeRange.create = function create(properties) {
          return new TimeRange(properties);
        };
        TimeRange.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.start != null && Object.hasOwnProperty.call(message, "start"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).uint64(message.start);
          if (message.end != null && Object.hasOwnProperty.call(message, "end"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).uint64(message.end);
          return writer;
        };
        TimeRange.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TimeRange.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.TimeRange();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.start = reader.uint64();
                break;
              }
              case 2: {
                message.end = reader.uint64();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TimeRange.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TimeRange.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.start != null && message.hasOwnProperty("start")) {
            if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
              return "start: integer|Long expected";
          }
          if (message.end != null && message.hasOwnProperty("end")) {
            if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
              return "end: integer|Long expected";
          }
          return null;
        };
        TimeRange.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.TimeRange)
            return object;
          var message = new $root.transit_realtime.TimeRange();
          if (object.start != null) {
            if ($util.Long)
              (message.start = $util.Long.fromValue(object.start)).unsigned = true;
            else if (typeof object.start === "string")
              message.start = parseInt(object.start, 10);
            else if (typeof object.start === "number")
              message.start = object.start;
            else if (typeof object.start === "object")
              message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber(true);
          }
          if (object.end != null) {
            if ($util.Long)
              (message.end = $util.Long.fromValue(object.end)).unsigned = true;
            else if (typeof object.end === "string")
              message.end = parseInt(object.end, 10);
            else if (typeof object.end === "number")
              message.end = object.end;
            else if (typeof object.end === "object")
              message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber(true);
          }
          return message;
        };
        TimeRange.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.start = options.longs === String ? "0" : 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, true);
              object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.end = options.longs === String ? "0" : 0;
          }
          if (message.start != null && message.hasOwnProperty("start"))
            if (typeof message.start === "number")
              object.start = options.longs === String ? String(message.start) : message.start;
            else
              object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber(true) : message.start;
          if (message.end != null && message.hasOwnProperty("end"))
            if (typeof message.end === "number")
              object.end = options.longs === String ? String(message.end) : message.end;
            else
              object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber(true) : message.end;
          return object;
        };
        TimeRange.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TimeRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.TimeRange";
        };
        return TimeRange;
      }();
      transit_realtime.Position = function() {
        function Position(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        Position.prototype.latitude = 0;
        Position.prototype.longitude = 0;
        Position.prototype.bearing = 0;
        Position.prototype.odometer = 0;
        Position.prototype.speed = 0;
        Position.create = function create(properties) {
          return new Position(properties);
        };
        Position.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          writer.uint32(
            /* id 1, wireType 5 =*/
            13
          ).float(message.latitude);
          writer.uint32(
            /* id 2, wireType 5 =*/
            21
          ).float(message.longitude);
          if (message.bearing != null && Object.hasOwnProperty.call(message, "bearing"))
            writer.uint32(
              /* id 3, wireType 5 =*/
              29
            ).float(message.bearing);
          if (message.odometer != null && Object.hasOwnProperty.call(message, "odometer"))
            writer.uint32(
              /* id 4, wireType 1 =*/
              33
            ).double(message.odometer);
          if (message.speed != null && Object.hasOwnProperty.call(message, "speed"))
            writer.uint32(
              /* id 5, wireType 5 =*/
              45
            ).float(message.speed);
          return writer;
        };
        Position.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        Position.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.Position();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.latitude = reader.float();
                break;
              }
              case 2: {
                message.longitude = reader.float();
                break;
              }
              case 3: {
                message.bearing = reader.float();
                break;
              }
              case 4: {
                message.odometer = reader.double();
                break;
              }
              case 5: {
                message.speed = reader.float();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          if (!message.hasOwnProperty("latitude"))
            throw $util.ProtocolError("missing required 'latitude'", { instance: message });
          if (!message.hasOwnProperty("longitude"))
            throw $util.ProtocolError("missing required 'longitude'", { instance: message });
          return message;
        };
        Position.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        Position.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (typeof message.latitude !== "number")
            return "latitude: number expected";
          if (typeof message.longitude !== "number")
            return "longitude: number expected";
          if (message.bearing != null && message.hasOwnProperty("bearing")) {
            if (typeof message.bearing !== "number")
              return "bearing: number expected";
          }
          if (message.odometer != null && message.hasOwnProperty("odometer")) {
            if (typeof message.odometer !== "number")
              return "odometer: number expected";
          }
          if (message.speed != null && message.hasOwnProperty("speed")) {
            if (typeof message.speed !== "number")
              return "speed: number expected";
          }
          return null;
        };
        Position.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.Position)
            return object;
          var message = new $root.transit_realtime.Position();
          if (object.latitude != null)
            message.latitude = Number(object.latitude);
          if (object.longitude != null)
            message.longitude = Number(object.longitude);
          if (object.bearing != null)
            message.bearing = Number(object.bearing);
          if (object.odometer != null)
            message.odometer = Number(object.odometer);
          if (object.speed != null)
            message.speed = Number(object.speed);
          return message;
        };
        Position.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.latitude = 0;
            object.longitude = 0;
            object.bearing = 0;
            object.odometer = 0;
            object.speed = 0;
          }
          if (message.latitude != null && message.hasOwnProperty("latitude"))
            object.latitude = options.json && !isFinite(message.latitude) ? String(message.latitude) : message.latitude;
          if (message.longitude != null && message.hasOwnProperty("longitude"))
            object.longitude = options.json && !isFinite(message.longitude) ? String(message.longitude) : message.longitude;
          if (message.bearing != null && message.hasOwnProperty("bearing"))
            object.bearing = options.json && !isFinite(message.bearing) ? String(message.bearing) : message.bearing;
          if (message.odometer != null && message.hasOwnProperty("odometer"))
            object.odometer = options.json && !isFinite(message.odometer) ? String(message.odometer) : message.odometer;
          if (message.speed != null && message.hasOwnProperty("speed"))
            object.speed = options.json && !isFinite(message.speed) ? String(message.speed) : message.speed;
          return object;
        };
        Position.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Position.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.Position";
        };
        return Position;
      }();
      transit_realtime.TripDescriptor = function() {
        function TripDescriptor(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TripDescriptor.prototype.tripId = "";
        TripDescriptor.prototype.routeId = "";
        TripDescriptor.prototype.directionId = 0;
        TripDescriptor.prototype.startTime = "";
        TripDescriptor.prototype.startDate = "";
        TripDescriptor.prototype.scheduleRelationship = 0;
        TripDescriptor.create = function create(properties) {
          return new TripDescriptor(properties);
        };
        TripDescriptor.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.tripId != null && Object.hasOwnProperty.call(message, "tripId"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.tripId);
          if (message.startTime != null && Object.hasOwnProperty.call(message, "startTime"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.startTime);
          if (message.startDate != null && Object.hasOwnProperty.call(message, "startDate"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.startDate);
          if (message.scheduleRelationship != null && Object.hasOwnProperty.call(message, "scheduleRelationship"))
            writer.uint32(
              /* id 4, wireType 0 =*/
              32
            ).int32(message.scheduleRelationship);
          if (message.routeId != null && Object.hasOwnProperty.call(message, "routeId"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).string(message.routeId);
          if (message.directionId != null && Object.hasOwnProperty.call(message, "directionId"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.directionId);
          return writer;
        };
        TripDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TripDescriptor.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.TripDescriptor();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.tripId = reader.string();
                break;
              }
              case 5: {
                message.routeId = reader.string();
                break;
              }
              case 6: {
                message.directionId = reader.uint32();
                break;
              }
              case 2: {
                message.startTime = reader.string();
                break;
              }
              case 3: {
                message.startDate = reader.string();
                break;
              }
              case 4: {
                message.scheduleRelationship = reader.int32();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TripDescriptor.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TripDescriptor.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.tripId != null && message.hasOwnProperty("tripId")) {
            if (!$util.isString(message.tripId))
              return "tripId: string expected";
          }
          if (message.routeId != null && message.hasOwnProperty("routeId")) {
            if (!$util.isString(message.routeId))
              return "routeId: string expected";
          }
          if (message.directionId != null && message.hasOwnProperty("directionId")) {
            if (!$util.isInteger(message.directionId))
              return "directionId: integer expected";
          }
          if (message.startTime != null && message.hasOwnProperty("startTime")) {
            if (!$util.isString(message.startTime))
              return "startTime: string expected";
          }
          if (message.startDate != null && message.hasOwnProperty("startDate")) {
            if (!$util.isString(message.startDate))
              return "startDate: string expected";
          }
          if (message.scheduleRelationship != null && message.hasOwnProperty("scheduleRelationship"))
            switch (message.scheduleRelationship) {
              default:
                return "scheduleRelationship: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 5:
              case 6:
                break;
            }
          return null;
        };
        TripDescriptor.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.TripDescriptor)
            return object;
          var message = new $root.transit_realtime.TripDescriptor();
          if (object.tripId != null)
            message.tripId = String(object.tripId);
          if (object.routeId != null)
            message.routeId = String(object.routeId);
          if (object.directionId != null)
            message.directionId = object.directionId >>> 0;
          if (object.startTime != null)
            message.startTime = String(object.startTime);
          if (object.startDate != null)
            message.startDate = String(object.startDate);
          switch (object.scheduleRelationship) {
            default:
              if (typeof object.scheduleRelationship === "number") {
                message.scheduleRelationship = object.scheduleRelationship;
                break;
              }
              break;
            case "SCHEDULED":
            case 0:
              message.scheduleRelationship = 0;
              break;
            case "ADDED":
            case 1:
              message.scheduleRelationship = 1;
              break;
            case "UNSCHEDULED":
            case 2:
              message.scheduleRelationship = 2;
              break;
            case "CANCELED":
            case 3:
              message.scheduleRelationship = 3;
              break;
            case "REPLACEMENT":
            case 5:
              message.scheduleRelationship = 5;
              break;
            case "DUPLICATED":
            case 6:
              message.scheduleRelationship = 6;
              break;
          }
          return message;
        };
        TripDescriptor.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.tripId = "";
            object.startTime = "";
            object.startDate = "";
            object.scheduleRelationship = options.enums === String ? "SCHEDULED" : 0;
            object.routeId = "";
            object.directionId = 0;
          }
          if (message.tripId != null && message.hasOwnProperty("tripId"))
            object.tripId = message.tripId;
          if (message.startTime != null && message.hasOwnProperty("startTime"))
            object.startTime = message.startTime;
          if (message.startDate != null && message.hasOwnProperty("startDate"))
            object.startDate = message.startDate;
          if (message.scheduleRelationship != null && message.hasOwnProperty("scheduleRelationship"))
            object.scheduleRelationship = options.enums === String ? $root.transit_realtime.TripDescriptor.ScheduleRelationship[message.scheduleRelationship] === void 0 ? message.scheduleRelationship : $root.transit_realtime.TripDescriptor.ScheduleRelationship[message.scheduleRelationship] : message.scheduleRelationship;
          if (message.routeId != null && message.hasOwnProperty("routeId"))
            object.routeId = message.routeId;
          if (message.directionId != null && message.hasOwnProperty("directionId"))
            object.directionId = message.directionId;
          return object;
        };
        TripDescriptor.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TripDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.TripDescriptor";
        };
        TripDescriptor.ScheduleRelationship = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "SCHEDULED"] = 0;
          values[valuesById[1] = "ADDED"] = 1;
          values[valuesById[2] = "UNSCHEDULED"] = 2;
          values[valuesById[3] = "CANCELED"] = 3;
          values[valuesById[5] = "REPLACEMENT"] = 5;
          values[valuesById[6] = "DUPLICATED"] = 6;
          return values;
        }();
        return TripDescriptor;
      }();
      transit_realtime.VehicleDescriptor = function() {
        function VehicleDescriptor(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        VehicleDescriptor.prototype.id = "";
        VehicleDescriptor.prototype.label = "";
        VehicleDescriptor.prototype.licensePlate = "";
        VehicleDescriptor.create = function create(properties) {
          return new VehicleDescriptor(properties);
        };
        VehicleDescriptor.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.id != null && Object.hasOwnProperty.call(message, "id"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.id);
          if (message.label != null && Object.hasOwnProperty.call(message, "label"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.label);
          if (message.licensePlate != null && Object.hasOwnProperty.call(message, "licensePlate"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.licensePlate);
          return writer;
        };
        VehicleDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        VehicleDescriptor.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.VehicleDescriptor();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.id = reader.string();
                break;
              }
              case 2: {
                message.label = reader.string();
                break;
              }
              case 3: {
                message.licensePlate = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        VehicleDescriptor.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        VehicleDescriptor.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.id != null && message.hasOwnProperty("id")) {
            if (!$util.isString(message.id))
              return "id: string expected";
          }
          if (message.label != null && message.hasOwnProperty("label")) {
            if (!$util.isString(message.label))
              return "label: string expected";
          }
          if (message.licensePlate != null && message.hasOwnProperty("licensePlate")) {
            if (!$util.isString(message.licensePlate))
              return "licensePlate: string expected";
          }
          return null;
        };
        VehicleDescriptor.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.VehicleDescriptor)
            return object;
          var message = new $root.transit_realtime.VehicleDescriptor();
          if (object.id != null)
            message.id = String(object.id);
          if (object.label != null)
            message.label = String(object.label);
          if (object.licensePlate != null)
            message.licensePlate = String(object.licensePlate);
          return message;
        };
        VehicleDescriptor.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.id = "";
            object.label = "";
            object.licensePlate = "";
          }
          if (message.id != null && message.hasOwnProperty("id"))
            object.id = message.id;
          if (message.label != null && message.hasOwnProperty("label"))
            object.label = message.label;
          if (message.licensePlate != null && message.hasOwnProperty("licensePlate"))
            object.licensePlate = message.licensePlate;
          return object;
        };
        VehicleDescriptor.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        VehicleDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.VehicleDescriptor";
        };
        return VehicleDescriptor;
      }();
      transit_realtime.EntitySelector = function() {
        function EntitySelector(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        EntitySelector.prototype.agencyId = "";
        EntitySelector.prototype.routeId = "";
        EntitySelector.prototype.routeType = 0;
        EntitySelector.prototype.trip = null;
        EntitySelector.prototype.stopId = "";
        EntitySelector.prototype.directionId = 0;
        EntitySelector.create = function create(properties) {
          return new EntitySelector(properties);
        };
        EntitySelector.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.agencyId != null && Object.hasOwnProperty.call(message, "agencyId"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.agencyId);
          if (message.routeId != null && Object.hasOwnProperty.call(message, "routeId"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.routeId);
          if (message.routeType != null && Object.hasOwnProperty.call(message, "routeType"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int32(message.routeType);
          if (message.trip != null && Object.hasOwnProperty.call(message, "trip"))
            $root.transit_realtime.TripDescriptor.encode(message.trip, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.stopId != null && Object.hasOwnProperty.call(message, "stopId"))
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).string(message.stopId);
          if (message.directionId != null && Object.hasOwnProperty.call(message, "directionId"))
            writer.uint32(
              /* id 6, wireType 0 =*/
              48
            ).uint32(message.directionId);
          return writer;
        };
        EntitySelector.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        EntitySelector.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.EntitySelector();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.agencyId = reader.string();
                break;
              }
              case 2: {
                message.routeId = reader.string();
                break;
              }
              case 3: {
                message.routeType = reader.int32();
                break;
              }
              case 4: {
                message.trip = $root.transit_realtime.TripDescriptor.decode(reader, reader.uint32());
                break;
              }
              case 5: {
                message.stopId = reader.string();
                break;
              }
              case 6: {
                message.directionId = reader.uint32();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        EntitySelector.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        EntitySelector.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.agencyId != null && message.hasOwnProperty("agencyId")) {
            if (!$util.isString(message.agencyId))
              return "agencyId: string expected";
          }
          if (message.routeId != null && message.hasOwnProperty("routeId")) {
            if (!$util.isString(message.routeId))
              return "routeId: string expected";
          }
          if (message.routeType != null && message.hasOwnProperty("routeType")) {
            if (!$util.isInteger(message.routeType))
              return "routeType: integer expected";
          }
          if (message.trip != null && message.hasOwnProperty("trip")) {
            var error = $root.transit_realtime.TripDescriptor.verify(message.trip);
            if (error)
              return "trip." + error;
          }
          if (message.stopId != null && message.hasOwnProperty("stopId")) {
            if (!$util.isString(message.stopId))
              return "stopId: string expected";
          }
          if (message.directionId != null && message.hasOwnProperty("directionId")) {
            if (!$util.isInteger(message.directionId))
              return "directionId: integer expected";
          }
          return null;
        };
        EntitySelector.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.EntitySelector)
            return object;
          var message = new $root.transit_realtime.EntitySelector();
          if (object.agencyId != null)
            message.agencyId = String(object.agencyId);
          if (object.routeId != null)
            message.routeId = String(object.routeId);
          if (object.routeType != null)
            message.routeType = object.routeType | 0;
          if (object.trip != null) {
            if (typeof object.trip !== "object")
              throw TypeError(".transit_realtime.EntitySelector.trip: object expected");
            message.trip = $root.transit_realtime.TripDescriptor.fromObject(object.trip);
          }
          if (object.stopId != null)
            message.stopId = String(object.stopId);
          if (object.directionId != null)
            message.directionId = object.directionId >>> 0;
          return message;
        };
        EntitySelector.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.agencyId = "";
            object.routeId = "";
            object.routeType = 0;
            object.trip = null;
            object.stopId = "";
            object.directionId = 0;
          }
          if (message.agencyId != null && message.hasOwnProperty("agencyId"))
            object.agencyId = message.agencyId;
          if (message.routeId != null && message.hasOwnProperty("routeId"))
            object.routeId = message.routeId;
          if (message.routeType != null && message.hasOwnProperty("routeType"))
            object.routeType = message.routeType;
          if (message.trip != null && message.hasOwnProperty("trip"))
            object.trip = $root.transit_realtime.TripDescriptor.toObject(message.trip, options);
          if (message.stopId != null && message.hasOwnProperty("stopId"))
            object.stopId = message.stopId;
          if (message.directionId != null && message.hasOwnProperty("directionId"))
            object.directionId = message.directionId;
          return object;
        };
        EntitySelector.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        EntitySelector.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.EntitySelector";
        };
        return EntitySelector;
      }();
      transit_realtime.TranslatedString = function() {
        function TranslatedString(properties) {
          this.translation = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TranslatedString.prototype.translation = $util.emptyArray;
        TranslatedString.create = function create(properties) {
          return new TranslatedString(properties);
        };
        TranslatedString.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.translation != null && message.translation.length)
            for (var i = 0; i < message.translation.length; ++i)
              $root.transit_realtime.TranslatedString.Translation.encode(message.translation[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          return writer;
        };
        TranslatedString.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TranslatedString.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.TranslatedString();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.translation && message.translation.length))
                  message.translation = [];
                message.translation.push($root.transit_realtime.TranslatedString.Translation.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TranslatedString.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TranslatedString.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.translation != null && message.hasOwnProperty("translation")) {
            if (!Array.isArray(message.translation))
              return "translation: array expected";
            for (var i = 0; i < message.translation.length; ++i) {
              var error = $root.transit_realtime.TranslatedString.Translation.verify(message.translation[i]);
              if (error)
                return "translation." + error;
            }
          }
          return null;
        };
        TranslatedString.fromObject = function fromObject(object) {
          if (object instanceof $root.transit_realtime.TranslatedString)
            return object;
          var message = new $root.transit_realtime.TranslatedString();
          if (object.translation) {
            if (!Array.isArray(object.translation))
              throw TypeError(".transit_realtime.TranslatedString.translation: array expected");
            message.translation = [];
            for (var i = 0; i < object.translation.length; ++i) {
              if (typeof object.translation[i] !== "object")
                throw TypeError(".transit_realtime.TranslatedString.translation: object expected");
              message.translation[i] = $root.transit_realtime.TranslatedString.Translation.fromObject(object.translation[i]);
            }
          }
          return message;
        };
        TranslatedString.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.translation = [];
          if (message.translation && message.translation.length) {
            object.translation = [];
            for (var j = 0; j < message.translation.length; ++j)
              object.translation[j] = $root.transit_realtime.TranslatedString.Translation.toObject(message.translation[j], options);
          }
          return object;
        };
        TranslatedString.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TranslatedString.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/transit_realtime.TranslatedString";
        };
        TranslatedString.Translation = function() {
          function Translation(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Translation.prototype.text = "";
          Translation.prototype.language = "";
          Translation.create = function create(properties) {
            return new Translation(properties);
          };
          Translation.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.text);
            if (message.language != null && Object.hasOwnProperty.call(message, "language"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.language);
            return writer;
          };
          Translation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Translation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.transit_realtime.TranslatedString.Translation();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.text = reader.string();
                  break;
                }
                case 2: {
                  message.language = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            if (!message.hasOwnProperty("text"))
              throw $util.ProtocolError("missing required 'text'", { instance: message });
            return message;
          };
          Translation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Translation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (!$util.isString(message.text))
              return "text: string expected";
            if (message.language != null && message.hasOwnProperty("language")) {
              if (!$util.isString(message.language))
                return "language: string expected";
            }
            return null;
          };
          Translation.fromObject = function fromObject(object) {
            if (object instanceof $root.transit_realtime.TranslatedString.Translation)
              return object;
            var message = new $root.transit_realtime.TranslatedString.Translation();
            if (object.text != null)
              message.text = String(object.text);
            if (object.language != null)
              message.language = String(object.language);
            return message;
          };
          Translation.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.text = "";
              object.language = "";
            }
            if (message.text != null && message.hasOwnProperty("text"))
              object.text = message.text;
            if (message.language != null && message.hasOwnProperty("language"))
              object.language = message.language;
            return object;
          };
          Translation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Translation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/transit_realtime.TranslatedString.Translation";
          };
          return Translation;
        }();
        return TranslatedString;
      }();
      return transit_realtime;
    }();
    module2.exports = $root;
  }
});
export default require_gtfs_realtime();
//# sourceMappingURL=gtfs-realtime-bindings.js.map
